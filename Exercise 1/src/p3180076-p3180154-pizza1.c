#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include "p3180076-p3180154-pizza1.h"

pthread_mutex_t lockcooker,lockoven,screen;//κάποια mutexes που θα χρησιμοποιήσουμε στη συνέχεια
pthread_cond_t ovens,cookers;//2 condition variables που θα χρειαστούμε για να κάνουμε wait και signal στην order

int numberOfCook = Ncook;//αρχικοποιούμε μία global μεταβλητή ώστε να ξέρουμε το ακριβή αριθμό των μαγείρων
int numberOfOven = Noven;//----------------------------------//---------------------------------των φόυρνων
unsigned int seed;//αυτή είναι η μεταβλητή στην οποία εκχωρείται ο σπόρος
double *timer;//δείκτης που θα χρησιμοποιηθεί παρακάτω για την δημιουργία δυναμικού πίνακα ώστε να αποθηκεύονται οι χρόνοι
double sum,max = 0;//μεταβλητές ώστε να βγουν τα συνολικά αποτελέσματα μέσου και μεγίστου χρόνου

int main(int argc, char *argv[]){
	if(argc != 3){
		printf("Λάθος! Θα πρέπει να δώσετε τον αριθμό των πελατών ΚΑΙ το σπόρο για την παραγωγή των τυχαίων αριθμών.\n");
		exit(-1);
	}//ελέγχουμε εάν τα ορίσματα είναι ακριβώς 3(->ονομα αρχείου ->αριθμός πελατών ->σπόρος) και αν δεν είναι τότε σταμματάει το πρόγραμμα

	int Ncust = atoi(argv[1]);//το Ncust έχει πλέον τον αριθμό πελατών

	if(Ncust <= 0){
		printf("Λάθος! Ο αριθμός των πελατών πρέπει να είναι θετικός ακέραιος.\n");
		exit(-1);
	}//εάν ο αριθμός πελατών είναι μικρότερος ή ίσος του 0 τότε βγάζει σφάλμα και σταμματάει το πρόγραμμα

	seed = atoi(argv[2]);//το seed περιέχει την τιμή του σπόρου
	unsigned int seed1 = seed;//αντιγράφουμε το seed σε τοπική μεταβλητή προκειμενου να μη χρησιμοποιήσουμε mutex 

	pthread_t threads[Ncust];//πίνακας τύπου thread όσος και ο αριθμός των πελατών
	pthread_mutex_init(&lockcooker,NULL);//initialization των αντίστοιχων mutexes
	pthread_mutex_init(&lockoven,NULL);//----------------//----------------------
	pthread_mutex_init(&screen,NULL);//------------------//----------------------
	pthread_cond_init(&ovens,NULL);//--------------------//---------του condition
	pthread_cond_init(&cookers,NULL);//------------------//----------------------

	int id[Ncust];//πίνακας μεγέθους όσος και ο αριθμός πελατών προκειμένου να αντιλαμβάνομαστε κατά την εκτέλεση την σειρά των παραγγελιών και να το περνάμε σαν όρισμα στο αντίστοιχο thread(πιο κάτω μέσα στο for)
	timer = malloc(Ncust*sizeof(double));//ορισμός μεγέθους του δυναμικού πίνακα για τους αντίστοιχους χρόνους

	for(int i = 0;i < Ncust;i++){
		if(i != 0){//η 1η έρχεται τη χρονική στιγμή 0 οπότε δεν χρειάζεται να περιμένει
			sleep(rand_r(&seed1) % Torderhigh + Torderlow);//το βάζουμε για ύπνο από 1-5 δευτερόλεπτα(Torderhigh = 5, Torderlow = 1 ==> random % Torderhigh + Torderlow = [1,5])
		}
		timer[i] = 0;//αρχικοποίηση του πίνακα των χρόνων με 0(μπορούσε να γίνει και με calloc πιο πάνω)
		id[i] = i+1;//αρχικοποίηση του πίνακα id με αριθμό i+1 ώστε να ξεκινάει ο αριθμός παραγγελιών από 1 και όχι από 0
		printf("Έγινε η παραλαβή της παραγγελίας: %d\n",i+1);//μήνυμα προς το χρήστη
		pthread_create(&threads[i],NULL,order,&id[i]);//δημιουργία των threads με ορίσματα το αντίστοιχο πεδίο του πίνακα των threads, κανένα attribute, τη συνάρτηση order και το id[i] για debugging
	}

	for (int i = 0;i < Ncust;i++){
		pthread_join(threads[i],NULL);//περιμένουμε να τερματίσουν τα νήματα
	}

	for (int i = 0;i < Ncust;i++){
		sum += timer[i];
		if(max < timer[i])
			max = timer[i];
	}//χρησιμοποιείται για να βγουν τα συγκεντρωτικά αποτελέσματα
	
	double lepta = (sum / Ncust);//μέσος χρόνος ανά παραγγελία
	
	pthread_mutex_lock(&screen);//κλείδωμα της οθόνης για εμφάνιση των αποτελεσμάτων
	printf("Ο μέσος χρόνος ολοκλήρωσης των παραγγελιών ειναι:%.2f λεπτά.\nΟ μέγιστος χρόνος ολοκλήρωσης των παραγγελιών ειναι:%.2f λεπτά\n",lepta,max);//Εμφανίζουμε τα αντίστοιχα μηνύματα για τον μέσο και μέγιστο χρόνο ολοκλήρωσης των παραγγελιών
	pthread_mutex_unlock(&screen);//ξεκλείδωμα της οθόνης

	free(timer);//απελευθερώνουμε  τον χώρο που έχουμε κρατήσει για τον δυναμικό πίνακα
	pthread_mutex_destroy(&lockcooker);//καταστρέφουμε το mutex που έχουμε δημιουργήσει
	pthread_mutex_destroy(&lockoven);//---------------------//-------------------------
	pthread_mutex_destroy(&screen);//-----------------------//-------------------------
	pthread_cond_destroy(&ovens);//-----------//--------το condition--------//---------
	pthread_cond_destroy(&cookers);//---------//--------το condition--------//---------
	return 0;//προκειμένου να τερματίσει το πρόγραμμα
}

void *order(void *x){
	struct timespec start,finish;//2 αντικείμενα της δομής timespec ώστε να παίρνουμε τον χρόνο στην αρχή και το τέλος της παραγγελίας
	int id = *(int*)x;//ο εκάστοτε αριθμός παραγγελίας
	unsigned int seed2 = seed + id;//αντιγράφουμε το seed σε τοπική μεταβλητή προκειμένου να μη χρησιμοποιήσουμε mutex και προσθέτουμε το id για μεγαλύτερη τυχαιότητα

	pthread_mutex_lock(&lockcooker);//κλειδώνουμε το mutex για τους μάγειρες
	clock_gettime(CLOCK_REALTIME,&start);//ξεκινάμε να μετράμε τον χρόνο της παραγγελίας(βασικά παίρνουμε την χρονικη στιγμή του ρολογιού)
	while (numberOfCook == 0){
		printf("Η παραγγελία %d δεν βρήκε παρασκευαστή! Είναι μπλοκαρισμένη...\n",id);
		pthread_cond_wait(&cookers,&lockcooker);
	}//όσο κανένας μάγειρας δεν είναι διαθέσιμος εμφανίζει μήνυμα ότι δεν βρήκε παρασκευαστή και περιμένει  
	//printf("Η παραγγελία %d εξυπηρετείται.\n",id);//όταν βγει από το while σημαίνει ότι απελευθερώθηκε ένας μάγειρας και άρα η παραγγελία εξυπηρετείται
	numberOfCook--;//μειώνουμε την global μεταβλητή που μετράει τον αριθμό των μαγείρων
	pthread_mutex_unlock(&lockcooker);//ξεκλειδώνουμε το mutex

	sleep((rand_r(&seed2) % Norderhigh + Norderlow) * Tprep);//το βάζουμε "για ύπνο" μέχρι να ετοιμαστεί (να γίνει δηλαδή η προετοιμασία πριν μπουν στο φούρνο)(random % 5 + 1)

	pthread_mutex_lock(&lockoven);//κλειδώνουμε το mutex για το φούρνο
	while (numberOfOven == 0){
		printf("Ο παρασκευαστής περιμένει να απελευθερωθεί ένας φούρνος. Οπότε η παραγγελία %d είναι έμμεσα μπλοκαρισμένη...\n",id);
		pthread_cond_wait(&ovens,&lockoven);
	}//όσο κανένας φούρνος δεν είναι διαθέσιμος εμφανίζει μήνυμα ότι δεν βρήκε διαθέσιμο φούρνο και περιμένει 
	//printf("Η παραγγελία %d μπαίνει στο φούρνο.\n",id);//όταν βγει από το while σημαίνει ότι απελευθερώθηκε ένας φούρνος και άρα η παραγγελία μπαίνει στο φούρνο
	numberOfOven--;//μειώνουμε την global μεταβλητή που μετράει τον αριθμό των φούρνων
	pthread_mutex_unlock(&lockoven);//ξεκλειδώνουμε το mutex για τους φούρνους

	sleep(Tbake);//το βάζουμε "για ύπνο" μέχρι να ετοιμαστεί (να ψηθούν δηλαδή οι πίτσες)

	pthread_mutex_lock(&lockcooker);//κλειδώνουμε το mutex για τους μάγειρες
	numberOfCook++;//αυξάνουμε τον αριθμό των μαγείρων αφού έχει τελειώσει και το ψήσιμο
	pthread_cond_signal(&cookers);//κάνουμε signal προκειμένου μία παραγγελία που είναι μπλοκαρισμένη και περιμένει μάγειρα να αρχίσει
	pthread_mutex_unlock(&lockcooker);//ξεκλειδώνουμε το mutex

	pthread_mutex_lock(&lockoven);//κλειδώνουμε το mutex για τους φούρνους 
	numberOfOven++;//αυξάνουμε τον αριθμό των φούρνων
	pthread_cond_signal(&ovens);//κανουμε signal προκειμένου μία παραγγελία που είναι μπλοκαρισμένη και περιμένει φούρνο να αρχίσει 
	pthread_mutex_unlock(&lockoven);//ξεκλειδώνουμε το mutex  

	pthread_mutex_lock(&screen);//κλειδώνουμε το mutex για την οθόνη 
	clock_gettime(CLOCK_REALTIME,&finish);//σταμματάμε να μετράμε τον χρόνο της παραγγελίας(βασικά παίρνουμε την χρονικη στιγμή του ρολογιού)
	double seconds = finish.tv_sec - start.tv_sec;//αφαιρούμε τις 2 χρονικές στιγμές και βρίσκουμε τον συνολικό χρόνο ολοκλήρωσης της παραγγελίας
	timer[id-1] = seconds;//εκχωρούμε τον χρόνο αυτό στον πίνακα timer με index id-1 διότι στη main συνάρτηση περνούσαμε σαν όρισμα το id+1
	printf("Η παραγγελία με αριθμό %d ετοιμάστηκε σε %d λεπτά.\n",id,(int)(seconds + 0.5));//εμφανίζουμε τη παραγγελία που εξυπηρετήθηκε καθώς και το χρόνο που χρειάστηκε(χρησιμοποιούμε το +0.5 για στρογγυλοποίηση πχ 2.3 -> 2(σωστό),2.8 -> 2(λάθος)|2.3+0.5=2.8 -> 2(σωστό),2.8+0.5=3.3 -> 3(σωστό))
	pthread_mutex_unlock(&screen);//ξεκλειδώνουμε το mutex για την οθόνη

	pthread_exit(NULL);//βγαίνουμε από το thread(δεν επιστρέφουμε κάτι στην main)
}
