#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include "p3180076-p3180154-pizza2.h"

pthread_mutex_t lockcooker,lockoven,lockdeliverer,screen;//κάποια mutexes που θα χρησιμοποιήσουμε στη συνέχεια
pthread_cond_t ovens,cookers,deliverers;//3 condition variables που θα χρειαστούμε για να κάνουμε wait και signal στην order

int numberOfCook = Ncook;//αρχικοποιούμε μία global μεταβλητή ώστε να ξέρουμε το ακριβή αριθμό των μαγείρων
int numberOfOven = Noven;//----------------------------------//---------------------------------των φόυρνων
int numberOfDeliverer = Ndeliverer;//------------------------//-------------------------------των διανομέων
unsigned int seed;//αυτή είναι η μεταβλητή στην οποία εκχωρείται ο σπόρος
double *timer,*timer2;//δείκτες που θα χρησιμοποιηθούν παρακάτω για την δημιουργία δυναμικών πινάκων ώστε να αποθηκεύονται οι χρόνοι
double sum,sum2,max,max2 = 0;//μεταβλητές ώστε να βγουν τα συνολικά αποτελέσματα μέσου και μεγίστου χρόνου ολοκλήρωσης/κρυώματος

int main(int argc, char *argv[]){
	if(argc != 3){
		printf("Λάθος! Θα πρέπει να δώσετε τον αριθμό των πελατών ΚΑΙ το σπόρο για την παραγωγή των τυχαίων αριθμών.\n");
		exit(-1);
	}//ελέγχουμε εάν τα ορίσματα είναι ακριβώς 3(->ονομα αρχείου ->αριθμός πελατών ->σπόρος) και αν δεν είναι τότε σταμματάει το πρόγραμμα

	int Ncust = atoi(argv[1]);//το Ncust έχει πλέον τον αριθμό πελατών

	if(Ncust <= 0){
		printf("Λάθος! Ο αριθμός των πελατών πρέπει να είναι θετικός ακέραιος.\n");
		exit(-1);
	}//εάν ο αριθμός πελατών είναι μικρότερος ή ίσος του 0 τότε βγάζει σφάλμα και σταμματάει το πρόγραμμα

	seed = atoi(argv[2]);//το seed περιέχει την τιμή του σπόρου
	unsigned int seed1 = seed;//αντιγράφουμε το seed σε τοπική μεταβλητή προκειμενου να μη χρησιμοποιήσουμε mutex 

	pthread_t threads[Ncust];//πίνακας τύπου thread όσος και ο αριθμός των πελατών
	pthread_mutex_init(&lockcooker,NULL);// initialization των αντίστοιχων mutexes
	pthread_mutex_init(&lockoven,NULL);//-----------------//----------------------
	pthread_mutex_init(&lockdeliverer,NULL);//------------//----------------------
	pthread_mutex_init(&screen,NULL);//-------------------//----------------------
	pthread_cond_init(&ovens,NULL);//---------------------//---------του condition
	pthread_cond_init(&cookers,NULL);//-------------------//----------------------
	pthread_cond_init(&deliverers,NULL);//----------------//----------------------

	int id[Ncust];//πίνακας μεγέθους όσος και ο αριθμός πελατών προκειμένου να αντιλαμβάνομαστε κατά την εκτέλεση την σειρά των παραγγελιών και να το περνάμε σαν όρισμα στο αντίστοιχο thread(πιο κάτω μέσα στο for)
	timer = malloc(Ncust*sizeof(double));//ορισμός μεγέθους του δυναμικού πίνακα για τους αντίστοιχους χρόνους ολοκλήρωσης των παραγγελιών
	timer2 = malloc(Ncust*sizeof(double));//ορισμός μεγέθους του δυναμικού πίνακα για τους αντίστοιχους χρόνους κρυώματος  ------//-------

	for(int i = 0;i < Ncust;i++){
		if(i != 0){//η 1η έρχεται τη χρονική στιγμή 0 οπότε δεν χρειάζεται να περιμένει
			sleep(rand_r(&seed1) % Torderhigh + Torderlow);//το βάζουμε "για ύπνο" από 1-5 δευτερόλεπτα(Torderhigh = 5, Torderlow = 1 ==> random % Torderhigh + Torderlow = [1,5])
		}
		timer[i] = 0;//αρχικοποίηση του πίνακα των χρόνων με 0
		timer2[i] = 0;//αρχικοποίηση του πίνακα των χρόνων με 0
		id[i] = i+1;//αρχικοποίηση του πίνακα id με αριθμό i+1 ώστε να ξεκινάει ο αριθμός παραγγελιών από 1 και όχι από 0
		printf("Έγινε η παραλαβή της παραγγελίας: %d\n",i+1);//μήνυμα προς το χρήστη
		pthread_create(&threads[i],NULL,order,&id[i]);//δημιουργία των threads με ορίσματα το αντίστοιχο πεδίο του πίνακα των threads, κανένα attribute, τη συνάρτηση order και το id[i] για debugging
	}

	for (int i = 0;i < Ncust;i++){
		pthread_join(threads[i],NULL);//περιμένουμε να τερματίσουν τα νήματα
	}

	for (int i = 0;i < Ncust;i++){
		sum += timer[i];
		sum2 += timer2[i];
		if(max2 < timer2[i])
			max2 = timer2[i];
		if(max < timer[i])
			max = timer[i];
	}//χρησιμοποιείται για να βγουν τα συγκεντρωτικά αποτελέσματα
	
	double lepta = (sum / Ncust);//μέσος χρόνος ολοκλήρωσης των παραγγελιών
	double lepta2 = (sum2 / Ncust);//μέσος χρόνος κρυώματος ------//-------

	pthread_mutex_lock(&screen);//κλείδωμα της οθόνης για εμφάνιση των αποτελεσμάτων
	printf("Ο μέσος χρόνος ολοκλήρωσης των παραγγελιών ειναι:%.2f λεπτά.\nΟ μέγιστος χρόνος ολοκλήρωσης των παραγγελιών ειναι:%.2f λεπτά\n",lepta,max);//Εμφανίζουμε τα αντίστοιχα μηνύματα για τον μέσο και μέγιστο χρόνο ολοκλήρωσης των παραγγελιών
	printf("Ο μέσος χρόνος κρυώματος των παραγγελιών ειναι:%.2f λεπτά.\nΟ μέγιστος χρόνος κρυώματος των παραγγελιών ειναι:%.2f λεπτά\n",lepta2,max2);//Εμφανίζουμε τα αντίστοιχα μηνύματα για τον μέσο και μέγιστο χρόνο κρυώματος των παραγγελιών
	pthread_mutex_unlock(&screen);//ξεκλείδωμα της οθόνης

	free(timer);//απελευθερώνουμε  τον χώρο που έχουμε κρατήσει για τον δυναμικό πίνακα
	free(timer2);//απελευθερώνουμε τον χώρο που έχουμε κρατήσει για τον δυναμικό πίνακα
	pthread_mutex_destroy(&lockcooker);//καταστρέφουμε το mutex που έχουμε δημιουργήσει
	pthread_mutex_destroy(&lockoven);//---------------------//-------------------------
	pthread_mutex_destroy(&lockdeliverer);//----------------//-------------------------
	pthread_mutex_destroy(&screen);//-----------------------//-------------------------
	pthread_cond_destroy(&ovens);//-----------//--------το condition--------//---------
	pthread_cond_destroy(&cookers);//---------//--------το condition--------//---------
	pthread_cond_destroy(&deliverers);//------//--------το condition--------//---------
	return 0;//προκειμένου να τερματίσει το πρόγραμμα
}

void *order(void *x){
	struct timespec start,finish,startfreezing;//2 αντικείμενα της δομής timespec ώστε να παίρνουμε τον χρόνο στην αρχή και το τέλος της παραγγελίας
	int id = *(int*)x;//ο εκάστοτε αριθμός παραγγελίας
	unsigned int seed2 = seed + id;//αντιγράφουμε το seed σε τοπική μεταβλητή προκειμένου να μη χρησιμοποιήσουμε mutex και προσθέτουμε το id για μεγαλύτερη τυχαιότητα
	unsigned int seed3 = seed - id;//αντιγράφουμε το seed σε τοπική μεταβλητή προκειμένου να μη χρησιμοποιήσουμε mutex και αφαιρούμε το id για μεγαλύτερη τυχαιότητα(αυτό θα χρησιμοποιηθεί για τον διανομέα)

	pthread_mutex_lock(&lockcooker);//κλειδώνουμε το mutex για τους μάγειρες
	clock_gettime(CLOCK_REALTIME,&start);//ξεκινάμε να μετράμε τον χρόνο της παραγγελίας(βασικά παίρνουμε την χρονικη στιγμή του ρολογιού)
	while (numberOfCook == 0){
		printf("Η παραγγελία %d δεν βρήκε παρασκευαστή! Είναι μπλοκαρισμένη...\n",id);
		pthread_cond_wait(&cookers,&lockcooker);
	}//όσο κανένας μάγειρας δεν είναι διαθέσιμος εμφανίζει μήνυμα ότι δεν βρήκε παρασκευαστή και περιμένει  
	printf("Η παραγγελία %d εξυπηρετείται.\n",id);//όταν βγει από το while σημαίνει ότι απελευθερώθηκε ένας μάγειρας και άρα η παραγγελία εξυπηρετείται
	numberOfCook--;//μειώνουμε την global μεταβλητή που μετράει τον αριθμό των μαγείρων
	pthread_mutex_unlock(&lockcooker);//ξεκλειδώνουμε το mutex

	sleep((rand_r(&seed2) % Norderhigh + Norderlow) * Tprep);//το βάζουμε "για ύπνο" μέχρι να ετοιμαστεί (να γίνει δηλαδή η προετοιμασία πριν μπουν στο φούρνο)(random % 5 + 1)

	pthread_mutex_lock(&lockoven);//κλειδώνουμε το mutex για το φούρνο
	while (numberOfOven == 0){
		printf("Ο παρασκευαστής περιμένει να απελευθερωθεί ένας φούρνος. Οπότε η παραγγελία %d είναι έμμεσα μπλοκαρισμένη...\n",id);
		pthread_cond_wait(&ovens,&lockoven);
	}//όσο κανένας φούρνος δεν είναι διαθέσιμος εμφανίζει μήνυμα ότι δεν βρήκε διαθέσιμο φούρνο και περιμένει 
	printf("Η παραγγελία %d μπαίνει στο φούρνο.\n",id);//όταν βγει από το while σημαίνει ότι απελευθερώθηκε ένας φούρνος και άρα η παραγγελία μπαίνει στο φούρνο
	numberOfOven--;//μειώνουμε την global μεταβλητή που μετράει τον αριθμό των φούρνων
	pthread_mutex_unlock(&lockoven);//ξεκλειδώνουμε το mutex για τους φούρνους

	pthread_mutex_lock(&lockcooker);//κλειδώνουμε το mutex για τους μάγειρες
	numberOfCook++;//αυξάνουμε τον αριθμό των μαγείρων αφού έχει τελειώσει και το ψήσιμο
	pthread_cond_signal(&cookers);//κάνουμε signal προκειμένου μία παραγγελία που είναι μπλοκαρισμένη και περιμένει μάγειρα να αρχίσει
	pthread_mutex_unlock(&lockcooker);//ξεκλειδώνουμε το mutex

	sleep(Tbake);//το βάζουμε "για ύπνο" μέχρι να ετοιμαστεί (να ψηθούν δηλαδή οι πίτσες)  
	clock_gettime(CLOCK_REALTIME,&startfreezing);//παίρνουμε τον χρόνο από την στιγμή που τελείωσε το ψήσιμο και αρχίζουν να κρυώνουν οι πίτσες

	pthread_mutex_lock(&lockdeliverer);//κλειδώνουμε το mutex για τους διανομείς
	while(numberOfDeliverer == 0){
		printf("Η παραγγελία %d κρυώνει στο φούρνο. Αναμένεται διανομέας για να την παραλάβει.\n",id);
		pthread_cond_wait(&deliverers,&lockdeliverer);
	}//όσο κανένας διανομέας δεν είναι διαθέσιμος εμφανίζει μήνυμα ότι δεν βρήκε διαθέσιμο διανομέα και περιμένει
	numberOfDeliverer--;//μειώνουμε την global μεταβλητή που μετράει τον αριθμό των διανομέων
	pthread_mutex_unlock(&lockdeliverer);//ξεκλειδώνουμε το mutex για τους διανομείς

	pthread_mutex_lock(&lockoven);//κλειδώνουμε το mutex για τους φούρνους 
	numberOfOven++;//αυξάνουμε τον αριθμό των φούρνων
	pthread_cond_signal(&ovens);//κανουμε signal προκειμένου μία παραγγελία που είναι μπλοκαρισμένη και περιμένει φούρνο να αρχίσει 
	pthread_mutex_unlock(&lockoven);//ξεκλειδώνουμε το mutex

	unsigned int deliverer_return = sleep(rand_r(&seed3) % (Thigh - Tlow + 1) + Tlow);//το βάζουμε "για ύπνο" για ένα τχαίο χρονικό διάστημα από 5 έως 15 και το αποθηκεύουμε το ίδιο διάστημα για την επιστροφή του διανομέα από το σπίτι στην πιτσαρία

	pthread_mutex_lock(&screen);//κλειδώνουμε το mutex για την οθόνη 
	clock_gettime(CLOCK_REALTIME,&finish);//σταμματάμε να μετράμε τον χρόνο της παραγγελίας(βασικά παίρνουμε την χρονικη στιγμή του ρολογιού)
	double seconds = finish.tv_sec - start.tv_sec;//αφαιρούμε τις 2 χρονικές στιγμές και βρίσκουμε τον συνολικό χρόνο ολοκλήρωσης της παραγγελίας
	double seconds2 = finish.tv_sec - startfreezing.tv_sec;//αφαιρούμε τις 2 χρονικές στιγμές και βρίσκουμε τον χρόνο κρυώματος της παραγγελίας
	timer[id-1] = seconds;//εκχωρούμε τον χρόνο seconds στον πίνακα timer με index id-1 διότι στη main συνάρτηση περνούσαμε σαν όρισμα το id+1
	timer2[id-1] = seconds2;//εκχωρούμε τον χρόνο seconds2 στον πίνακα timer2 με index id-1 διότι στη main συνάρτηση περνούσαμε σαν όρισμα το id+1
	printf("Η παραγγελία με αριθμό %d παραδόθηκε σε %d λεπτά και κρύωνε %d λεπτά.\nΟ διανομέας επιστρέφει στην πιτσαρία\n",id,(int)(seconds + 0.5),(int)(seconds2 + 0.5));//εμφανίζουμε τη παραγγελία που εξυπηρετήθηκε καθώς και το χρόνο που χρειάστηκε(χρησιμοποιούμε το +0.5 για στρογγυλοποίηση πχ 2.3 -> 2(σωστό),2.8 -> 2(λάθος)|2.3+0.5=2.8 -> 2(σωστό),2.8+0.5=3.3 -> 3(σωστό)).Είναι ένας γρήγορος τρόπος στρογγυλοποίησης
	pthread_mutex_unlock(&screen);//ξεκλειδώνουμε το mutex για την οθόνη
	
	sleep(deliverer_return);//το βάζουμε "για ύπνο" για χρονικό διάστημα ίσο με αυτό για την μεταφορά της πίτσας από την πιτσαρία προς το σπίτι

	pthread_mutex_lock(&lockdeliverer);//κλειδώνουμε το mutex για τους διανομείς
	numberOfDeliverer++;//αυξάνουμε τον αριθμό των διανομέων(αφου έχει γυρίσει πλέον στην πιτσαρία)
	pthread_cond_signal(&deliverers);//κανουμε signal προκειμένου μία παραγγελία που είναι μπλοκαρισμένη και περιμένει διανομέα να αρχίσει
	pthread_mutex_unlock(&lockdeliverer);//ξεκλειδώνουμε το mutex

	pthread_exit(NULL);//βγαίνουμε από το thread(δεν επιστρέφουμε κάτι στην main)
}
